<!DOCTYPE html>
<html>
<head>
  <title>RaspberryPi homeautomation</title>
</head>

<body>
	
 <h1>Parts:</h1>

<h2>Master Domoticz RaspberryPi B+ (512Mb memory)</h2>
<ul>
  <li>zWave USB dongle (aeotec Z-Stick Series 2)</li>
  <li>USB Wlan dongle</li>
  <li>MEMS sensor evaluating board</li>
</ul>

<h2>Z-Wave:</h2>
<ul>
  <li>Siren & Alarm light ZM1601</li>
  <li>Motion sensor & Temp & Luminance & Humidity Aeotec 4 in 1 DSB05</li>
  <li>2 x Door magnetic sensors ZD2102</li>
</ul>

<h2>Further reading:</h2>
<a href="http://www.element14.com/community/community/designcenter/mems-sensor-board">http://www.element14.com/community/community/designcenter/mems-sensor-board</a>

<h2>Slave (in Boiler room) Domoticz RaspberryPi B (256Mb memory)</h2>
<ul>
  <li>USB Wlan dongle</li>
  <li>4 x DS18B20+ temperature sensors (one wire)</li>
  <li>1 x 4.7K Ohm resistor (used for pullup on GPIO)</li>
  <li>1 x HC-SR501 PIR sensor</li>
</ul>

<h2>Further reading:</h2>
<a href="http://www.modmypi.com/blog/raspberry-pi-gpio-sensing-motion-detection">http://www.modmypi.com/blog/raspberry-pi-gpio-sensing-motion-detection</a><br>
<a href="http://www.mpja.com/download/31227sc.pdf">http://www.mpja.com/download/31227sc.pdf</a>
<h1>Source codes for used scripts</h1>
	
<h2>PIR Python source:</h2>
import RPi.GPIO as GPIO
<br>import urllib
<br>import urllib2
<br>import time
<br>
<br>GPIO.setmode(GPIO.BCM)
<br>PIR_PIN = 7
<br>GPIO.setup(PIR_PIN, GPIO.IN)
<br>
<br>def MOTION(PIR_PIN):
<br>               print "Motion Detected!"
<br>               url = "http://192.168.1.1:8080/json.htm?type=command&param=switchlight&idx=31&switchcmd=On&level=0"
<br>              f = urllib2.urlopen(url)
<br>               print url
<br>               time.sleep(60)
<br>               url = "http://192.168.1.1:8080/json.htm?type=command&param=switchlight&idx=31&switchcmd=Off&level=0"
<br>               f = urllib2.urlopen(url)
<br>               print url
<br>print "PIR Module Test (CTRL+C to exit)"
<br>time.sleep(2)
<br>print "Ready"
<br>try:
<br>
<br>               GPIO.add_event_detect(PIR_PIN, GPIO.RISING, callback=MOTION)
<br>               while 1:
<br>                              time.sleep(100)
<br>except KeyboardInterrupt:
<br>               print " Quit"
<br>               GPIO.cleanup()
<br>
<h2>Debugging GPIO temp reading source:</h2>
Usage: sudo python [script name] [One wire address] [domoticz virtual sensor ID]
<br>
<br>import os
<br>import time
<br>import urllib
<br>import urllib2
<br>import sys, getopt
<br>
<br>w1TempAddress = str(sys.argv[1])
<br>domoIDX = str(sys.argv[2])
<br>
<br>print w1TempAddress
<br>print domoIDX
<br>os.system('modprobe w1-gpio')
<br>os.system('modprobe w1-therm')
<br>temp_sensor = '/sys/bus/w1/devices/' + w1TempAddress + '/w1_slave'
<br>def temp_raw():
<br>    f = open(temp_sensor, 'r')
<br>    lines = f.readlines()
<br>    f.close()
<br>    return lines
<br>
<br>def read_temp():
<br>    lines = temp_raw()
<br>    while lines[0].strip()[-3:] != 'YES':
<br>        time.sleep(0.2)
<br>        lines = temp_raw()
<br>    temp_output = lines[1].find('t=')
<br>
<br>    if temp_output != -1:
<br>        temp_string = lines[1].strip()[temp_output+2:]
<br>        temp_c = float(temp_string) / 1000.0
<br>        temp_f = temp_c * 9.0 / 5.0 + 32.0
<br>        url = "http://192.168.1.1:8080/json.htm?type=command&param=udevice&idx=%s&nvalue=0&svalue=%.02f" % (domoIDX,temp_c)
<br>        f = urllib2.urlopen(url)
<br>        print url
<br>        #return temp_c
<br>
<br>read_temp()
<br>
<h2>Reset PIR sensor (debugging) source:</h2>

<br>import RPi.GPIO as GPIO
<br>import urllib
<br>import urllib2
<br>import time
<br>
<br>url = "http://192.168.1.1:8080/json.htm?type=command&param=switchlight&idx=31&switchcmd=Off&level=0"
<br>f = urllib2.urlopen(url)
<br>print url

<h2>BASH get temp sensor addresses:</h2>

<br>#!/bin/bash
<br># This script enables oneWire and reads the temp
<br>
<br>sudo modprobe w1-gpio
<br>sudo modprobe w1-therm
<br>
<br>cd /sys/bus/w1/devices/
<br>ls
<br>
<br>cd ~

<h2>XTRINSIC MEMS Board reading python source:</h2>

<br>#!/usr/bin/env python
<br>import math
<br>import time
<br>import urllib
<br>import urllib2
<br>from ctypes import *
<br>from decimal import *
<br>#cdll.LoadLibrary("./bcm2835.so")
<br>
<br>sensor = CDLL("./sensor.so")
<br>
<br>class mpl3115a2:
<br>        def __init__(self):
<br>                if (0 == sensor.bcm2835_init()):
<br>                        print "bcm3835 driver init failed."
<br>                        return
<br>
<br>        def writeRegister(self, register, value):
<br>            sensor.MPL3115A2_WRITE_REGISTER(register, value)
<br>
<br>        def readRegister(self, register):
<br>                return sensor.MPL3115A2_READ_REGISTER(register)
<br>
<br>        def active(self):
<br>                sensor.MPL3115A2_Active()
<br>
<br>        def standby(self):
<br>                sensor.MPL3115A2_Standby()
<br>
<br>        def initAlt(self):
<br>                sensor.MPL3115A2_Init_Alt()
<br>
<br>        def initBar(self):
<br>                sensor.MPL3115A2_Init_Bar()
<br>
<br>        def readAlt(self):
<br>                return sensor.MPL3115A2_Read_Alt()
<br>
<br>        def readTemp(self):
<br>                return sensor.MPL3115A2_Read_Temp()
<br>
<br>        def setOSR(self, osr):
<br>                sensor.MPL3115A2_SetOSR(osr);
<br>
<br>        def setStepTime(self, step):
<br>                sensor.MPL3115A2_SetStepTime(step)
<br>
<br>        def getTemp(self):
<br>                t = self.readTemp()
<br>                t_m = (t >> 8) & 0xff;
<br>                t_l = t & 0xff;
<br>                t_l = t_l >> 4;
<br>                t_l = t_l * 0.0625;
<br>
<br>                return (t_m + t_l)
<br>
<br>        def getAlt(self):
<br>                alt = self.readAlt()
<br>                alt_m = alt >> 8
<br>                alt_l = alt & 0xff
<br>
<br>                if (alt_l > 99):
<br>                        alt_l = alt_l / 1000.0
<br>                else:
<br>                        alt_l = alt_l / 100.0
<br>
<br>                return self.twosToInt(alt_m, 16) + alt_l
<br>        def getBar(self):
<br>                alt = self.readAlt()
<br>                alt_m = alt >> 6
<br>                alt_l = alt & 0x03
<br>
<br>                if (alt_l > 99):
<br>                        alt_l = alt_l
<br>                else:
<br>                        alt_l = alt_l
<br>
<br>                return (self.twosToInt(alt_m, 18))
<br>
<br>        def twosToInt(self, val, len):
<br>                # Convert twos compliment to integer
<br>                if(val & (1 << len - 1)):
<br>                        val = val - (1<<len)
<br>
<br>                return val
<br>
<br>mpl = mpl3115a2()
<br>mpl.initBar()
<br>#mpl.setOSR(128)
<br>mpl.active()
<br>time.sleep(5)
<br>TEMP = mpl.getTemp()
<br>BAR = mpl.getBar()
<br>i = str(BAR)
<br>
<br>if i[0] == "1":
<br>        i = float(i[:4] + '.' + i[2:])
<br>else:
<br>        i = float(i[:3] + '.' + i[3:])
<br>url = "http://192.168.1.1:8080/json.htm?type=command&param=udevice&idx=19&nvalue=0&svalue=%.02f;50;HUM_STAT;%.2f;BAR_FOR" % (TEMP,i)
<br>f = urllib2.urlopen(url)
<br>print url
<br>
<h2>Oil consumption from temperature python script</h2>
<br>import os
<br>import time
<br>import urllib
<br>import urllib2
<br>import sys, getopt
<br>
<br>#-----------------------------------------
<br># ToDo: Clean the code!
<br>#-----------------------------------------
<br>
<br>oil_start_level = 1000 # Oil start level in litres
<br>oil_consumption = 2 # Oil consumption in litres per hour (depends on your oil burner nozzle)
<br>domoticzURL = "http://192.168.1.1:8080"
<br>
<br>### Don't touch under this line !!! ###
<br># ------------------------------------#
<br>temperatureTemporaryData = "temperature_data.txt"
<br>percentageTemporaryFile = "remaining-oil.txt"
<br>w1TempAddress = str(sys.argv[1]) # Don't touch this! Reads one wire address from CLI
<br>domoIDX = str(sys.argv[2]) # Don't touch this! Reads percentage counter address from CLI
<br>print w1TempAddress
<br>print domoIDX
<br># Let's do the 1w trics to get the temp
<br>os.system('modprobe w1-gpio')
<br>os.system('modprobe w1-therm')
<br>temp_sensor = '/sys/bus/w1/devices/' + w1TempAddress + '/w1_slave'
<br>
<br>def read_from_file(temperatureTemporaryData):
<br>        with open(temperatureTemporaryData, 'r') as f:
<br>                my_list = [line.rstrip('\n') for line in f]
<br>        return my_list
<br>
<br>def write_to_file(temperatureTemporaryData,data):
<br>        with open(temperatureTemporaryData, 'w') as f:
<br>                for s in data:
<br>                        f.write(str(s) + '\n')
<br>
<br>def write_single_line_to_file(temperatureTemporaryData,data):
<br>        with open(temperatureTemporaryData, 'w') as f:
<br>                f.write(data + '\n')
<br>
<br>def temp_raw():
<br>    f = open(temp_sensor, 'r')
<br>    lines = f.readlines()
<br>    f.close()
<br>    return lines
<br>
<br>def write_data_to_domo(domoIDX,current_percentage):
<br>        url = "%s/json.htm?type=command&param=udevice&idx=%s&nvalue=0&svalue=%.02f" % (domoticzURL,domoIDX,current_percentage)
<br>        f = urllib2.urlopen(url)
<br>        print url
<br>
<br>def read_temp():
<br>    lines = temp_raw()
<br>    while lines[0].strip()[-3:] != 'YES':
<br>        time.sleep(0.2)
<br>        lines = temp_raw()
<br>    temp_output = lines[1].find('t=')
<br>
<br>    if temp_output != -1:
<br>        temp_string = lines[1].strip()[temp_output+2:]
<br>        temp_c = float(temp_string) / 1000.0
<br>        temp_f = temp_c * 9.0 / 5.0 + 32.0
<br>        return round(temp_c,2)
<br>
<br>def get_average_temp(tempArray):
<br>        temp = 0
<br>        average = 0
<br>        for temp in tempArray:
<br>                average = float(average)
<br>                average = average + float(temp)
<br>        average = average / 60
<br>        return round(average,2)
<br>
<br>def count_percentage(percentageTemporaryFile,elapsed_time,oil_consumption,oil_start_level):
<br>        old_level = read_from_file(percentageTemporaryFile) # ToDo: use same file for all data!!!
<br>        new_oil_level = float(old_level[0]) - ((float(oil_consumption)/3600)*elapsed_time)
<br>        new_percentage = (new_oil_level / oil_start_level) * 100
<br>write_single_line_to_file(percentageTemporaryFile,str(new_oil_level))
<br>        return new_percentage,new_oil_level
<br>
<br>def isTempRising(new_temp,average): # Check that is temperature rising
<br>        verdict = False
<br>        #print "Average: ",average
<br>        print "New temp: ", new_temp
<br>        if new_temp >= average:
<br>                verdict = True
<br>        else:
<br>                verdict = False
<br>        return verdict
<br>
<br>def writeNewTempToArray(array,new_temp): # remove last element from array and add new
<br>        array.pop(59)
<br>        array.insert(0,new_temp)
<br>        return array
<br>
<br>count = 0
<br>while (count != 1): # Forever loop :)
<br>        tempratureRising = False
<br>        new_temp = read_temp() # get new temperature from oneWire device
<br>        earlierTempArray = read_from_file(temperatureTemporaryData) # Get last 60 temps from file
<br>        average = get_average_temp(earlierTempArray) # Count average temperature based on earlier temps
<br>        temperatureRising = isTempRising(new_temp,average) # Check is temp rising
<br>
<br>        if temperatureRising == True:
<br>                start_time = time.time() # Start timing when temp rising
<br>                while temperatureRising == True:
<br>                        new_temp = read_temp() # get new temperature from oneWire device
<br>                        earlierTempArray = writeNewTempToArray(earlierTempArray,new_temp) # Get earlier temp data
<br>                        average = get_average_temp(earlierTempArray) # Count average temperature based on earlier temps
<br>                        write_to_file(temperatureTemporaryData,earlierTempArray)
<br>                        temperatureRising = isTempRising(new_temp,average) # Check is temp rising
<br>                        print "Aika: ",time.time() - start_time
<br>                        time.sleep(2)
<br>                elapsed_time = time.time() - start_time # Stop timing when temp stops rising
<br>                print "Polttoaika: ",elapsed_time
<br>                current_percentage,new_oil_level = count_percentage(percentageTemporaryFile,elapsed_time,oil_consumption,oil_start_level) # Count remaining oil percentage
<br>                write_data_to_domo(domoIDX,current_percentage) # Write percentage to Domoticz virtual device
<br>                write_data_to_domo(45,new_oil_level) # Write percentage to Domoticz virtual device
<br>
<br>        earlierTempArray = writeNewTempToArray(earlierTempArray,new_temp)
<br>        write_to_file(temperatureTemporaryData,earlierTempArray)
<br>        time.sleep(5) # delays for n seconds

<h1>In future:</h1>
Propably Flame sensor on LDR will be conneted to rPi to sense when oilburner is generating warm water / heat to the house.
<br><a href="http://www.oracle.com/technetwork/articles/java/cruz-gpio-2295970.html">http://www.oracle.com/technetwork/articles/java/cruz-gpio-2295970.html</a>
<br>Also heat pump will be controlled via Zwave in future using by ZXT-120 IR module

</body>
</html>
